<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xmlns:context="http://www.springframework.org/schema/context"
	   xmlns:aop="http://www.springframework.org/schema/aop"
	   xmlns:tx="http://www.springframework.org/schema/tx" xmlns:mvc="http://www.springframework.org/schema/mvc"
	   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd
		http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd
		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd">


	<!-- Spring的配置文件，这里主要配置和业务逻辑有关的 -->

	<!-- 扫描除了控制器之外的  讲业务逻辑组件全部加入进来 -->
	<context:component-scan base-package="com.liufeng"/>



	<!-- 先引入这个外部的配置文件 然后就可以在这个文件里面使用美元加大括号提取其中的属性值 -->
	<context:property-placeholder location="classpath:dbconfig.properties"/>
	<!-- 1数据源 事物控制 核心业务逻辑组件 -->

	<bean id ="pooledDataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
		<property name="jdbcUrl" value="${jdbc.jdbcUrl}"/>
		<property name="driverClass" value="${jdbc.driverClass}"/>
		<property name="user" value="${jdbc.user}"/>
		<property name="password" value="${jdbc.password}"/>
	</bean>

	<!-- 2 配置与Mybatis的整合-->

	<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
		<!-- 指定一个mybatis全局配置文件 -->
		<property name="mapperLocations" value="classpath:mapper/*.xml"/>
		<property name="configLocation" value="classpath:mybatis-config.xml"/>
		<property name="dataSource" ref="pooledDataSource"/>
	</bean>

	<!-- 批量插入的sqlsession  时间上会变慢 但是线程安全  -->
	<bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate">
		<constructor-arg name="sqlSessionFactory" ref="sqlSessionFactory"/>
		<!--<constructor-arg name="executorType" value="BATCH"></constructor-arg>--> <!--这里如果设置成batch的话有可能造成删除 更改返回-2147482646-->
	</bean>

	<!-- 配置扫描器 将mubatis接口的实现(dao下)加入IOC容器 -->
	<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
		<property name="basePackage" value="com.liufeng.npc.dao"/>
	</bean>


	<!-- 3事物控制的配置  熟练-->

	<bean  id ="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<!-- 控制住数据源 开启关闭回滚操作使用这个事物管理器来做 -->
		<property name="dataSource" ref="pooledDataSource"/>

	</bean>

	<!--上传文件的支持-->


	<bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
		<property name="defaultEncoding" value="UTF-8"/>
		<property name="maxUploadSizePerFile" value="10485760"/>
		<property name="maxUploadSize" value="209715200"/>
		<!--resolveLazily属性启用是为了推迟文件解析，以便在UploadAction 中捕获文件大小异常-->
		<property name="resolveLazily" value="true"/>

	</bean>
	<!--======================shiro===================================================-->
	<!--shiro 创建自己的或者提供的realm cache等东西 方便加入managert-->
	<bean id="sampleJDBCRealm" class="org.apache.shiro.realm.jdbc.JdbcRealm">
		<property name="dataSource" ref="pooledDataSource"/><!--提供这个realm数据源-->
		<!--登陆认证用户的查询sql 必须要以登陆名为条件 查询密码字段-->
		<property name="authenticationQuery" value="select t.pwd from my_user t where t.username=?"/>
		<!--查询用户角色的sql 必须以登陆名为条件 查询用户角色名字段-->
		<property name="userRolesQuery" value="select a.rolename from my_user t left join my_role a on t.roleid=a.id where t.username=?"/>
		<!--查询出某个角色下的权限资源  如果存在多个角色，则是遍历每个角色，分别查询出权限资源并添加到集合中。
			my_permission 存有权限资源 permissionName  permissionId

			my_role_permission 角色和权限的结合 存有角色ID 权限ID role_id permission_id

			my_role 存有rolename roleID 角色表-->
		<property name="permissionsQuery" value="select p.permissionName
			from my_role r left join my_role_permission rp
			on r.id = rp.role_id
			left join my_permission p
			on rp.permission_id = p.id
			where r.rolename = ? "/>
		<!--默认false。False时不会使用permissionsQuery的SQL去查询权限资源。设置为true才会去执行。-->
		<property name="permissionsLookupEnabled" value="true" />
		<!--saltStyle 密码是否加盐，默认是NO_SALT不加盐。加盐有三种选择CRYPT,COLUMN,EXTERNAL。这里不加盐处理。-->
		<property name="saltStyle" value="NO_SALT" />
		<!--密码匹配规则-->
		<property name="credentialsMatcher" ref="hashedCredentialsMatcher" />

	</bean>

	<bean id="hashedCredentialsMatcher"
		  class="org.apache.shiro.authc.credential.HashedCredentialsMatcher">
		<!--加密方式可以有MD5或者SHA-1，如果对密码安全有更高要求可以用SHA-256或者更高。这里使用MD5-->
		<property name="hashAlgorithmName" value="MD5" />
		<!--默认是true，此时用的是密码加密用的是Hex编码；false时用Base64编码-->
		<property name="storedCredentialsHexEncoded" value="true" />
		<!--hashIterations 迭代次数，重复加密几次 默认值是1。-->
		<property name="hashIterations" value="1" />
	</bean>

<!--2.1 缓存管理器 这里使用ehchacheManager ehcache没有使用配置文件 如果要用的话使用property-->
	<bean id="cacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager"/>
<!--2.2 自定义的realm -->
	<bean id="testRealm" class="com.liufeng.npc.realm.TestRealm"/>

	<!--2. shiro securityManagerper 增加缓存管理器，realm等-->
	<bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
		<!--在这里面配置realm cache 等东西-->
		<property name="cacheManager" ref="cacheManager"/>
		<!--可以使用自己的realm 这里使用继承realm接口的自定义realm-->
		<property name="realm" ref="testRealm"/>
		<!--如果有多个realm 就用realms-->
	</bean>
<!--&lt;!&ndash;3 配置 lifecycleBeanPostProcessor 自动调用在spirngIOC中shiro bean 的生命周期&ndash;&gt;-->
	<!--<bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor"/>-->
	<!--&lt;!&ndash;4 启用IOC 容器中使使用shiro注解 必须配置生命管理器的情况下才可以&ndash;&gt;-->
	<!--<bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"-->
		  <!--depends-on="lifecycleBeanPostProcessor"/>-->
	<!--<bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor">-->
		<!--<property name="securityManager" ref="securityManager"/>-->
	<!--</bean>-->

	<!--5.shiro 过滤器 这里过滤器的名字要和web xml里面配置的过滤器的名字一样-->
	<bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
		<!--必要的管理器-->
		<property name="securityManager" ref="securityManager" />
		<!--登陆的URL 如果没有会自动找webapps底下的login.jsp-->
		<property name="loginUrl" value="/admin"/>
		<!--successUrl ：登录成功默认跳转页面，不配置则跳转至”/”。如果登陆前点击的一个需要登录的页面，则在登录自动跳转到那个需要登录的页面。不跳转到此。-->
		<property name="successUrl" value="/admin/main"/>
		<!--没有权限自动跳转的页面-->
		<property name="unauthorizedUrl" value="/admin"/>

		<!--
			在这里面配置需要被保护的资源
			过滤器:
			anon: 可以匿名访问的资源 /admin/login = anon
			authc: 需要登录才可以访问的资源 /admin/** = authc
			anon:例子/static/**=anon 没有参数，表示home开头的 可以匿名使访问一般用于静态资源
			authc:例如/admins/**=authc表示如果没有登录就会跳转到loginUrl定义的登录界面 登录成功后 默认跳转地址successUrl定义的地址


			roles：例子/admins/user/**=roles[admin],参数可以写多个，多个时必须加上引号，
			并且参数之间用逗号分割，当有多个参数时，例如admins/user/**=roles["admin,guest"],
			每个参数通过才算通过
			perms：例子/admins/user/**=perms[user:add:*],参数可以写多个，多个时必须加上引号，
			并且参数之间用逗号分割，
			例如/admins/user/**=perms["user:add:*,user:modify:*"]，
			当有多个参数时必须每个参数都通过才通过

            rest：例子/admins/user/**=rest[user],根据请求的方法，相当于/admins/user/**=perms[user:method] ,其中method为post，get，delete等。
            port：例子/admins/user/**=port[8081],当请求的url的端口不是8081是跳转到schemal://serverName:8081?queryString,其中schmal是协议http或https等，serverName是你访问的host,8081是url配置里port的端口，queryString
            是你访问的url里的？后面的参数。
            authcBasic：例如/admins/user/**=authcBasic没有参数表示httpBasic认证
            ssl:例子/admins/user/**=ssl没有参数，表示安全的url请求，协议为https
            user:例如/admins/user/**=user没有参数表示必须存在用户，当登入操作时不做检查


            anon，authcBasic，auchc，user是身份验证拦截器，
            perms，roles，ssl，rest，port是授权相关拦截器

			按照顺序过滤

		-->
		<property name="filterChainDefinitions">
			<value>
				/admin = anon
				/admin/** = authc
				/** = anon

			</value>
		</property>
	</bean>


	<!--&lt;!&ndash; 配置视图解析器 html方便页面放回 &ndash;&gt;-->
	<bean id="freemakerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer">
		<property name="templateLoaderPath" value="/WEB-INF/ligerView/"/>
		<!-- FreeMarker默认每隔5秒检查模板是否被更新，如果已经更新了，就会重新加载并分析模板。 但经常检查模板是否更新可能比较耗时。如果你的应用运行在生产模式下，而且你预期模板不会经常更新，
           则可以将更新的延迟时间延长至一个小时或者更久。 可以通过为freemarkerSettings属性设置template_update_delay达到这一目的 -->
		<property name="freemarkerSettings">
			<props>
				<prop key="template_update_delay">3600</prop>
				<prop key="default_encoding">UTF-8</prop>
				<prop key="output_encoding">UTF-8</prop>
			</props>
		</property>
	</bean>
	<bean id="htmlviewResolver" class="org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver">
		<property name="suffix" value=".html" />
		<property name="order" value="0"/>
		<property name="contentType" value="text/html;charset=UTF-8"/>
	</bean>



	<!--<mvc:resources mapping="/ligerView/*.html" location="ligerView"/>-->
	<!-- 配置视图解析器 jsp方便页面放回 -->
	<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="prefix" value="/WEB-INF/views/"/>
		<property name="suffix" value=".jsp"/>
		<property name="order" value="1"/>
	</bean>

	<mvc:interceptors>
		<mvc:interceptor>
			<mvc:mapping path="/**"/>
			<bean class="com.liufeng.npc.Interceptor.AccessStatisticsIntceptor"/>
		</mvc:interceptor>
	</mvc:interceptors>
	<!-- 两个标准 -->
	<!-- 讲springMVC 不能处理的请求交给tomcat -->
	<mvc:default-servlet-handler/>
	<!-- 能支持springMVC 更高级一些的功能。 JSR303校验 快捷ajax 映射动态请求 -->
	<mvc:annotation-driven/>


	<!-- 开启基于注解的事物吗，使用xml形式的事物（主要使用的事配置试） -->
	<aop:config>
		<!-- 切入点表达式  -->
		<aop:pointcut expression="execution(* com.liufeng.npc.service..*(..))" id="txPoint"/>
		<!-- 配置事物增强 -->
		<aop:advisor advice-ref="txAdvice" pointcut-ref="txPoint"/>
	</aop:config>


	<!-- 配置事物增强 也就是事物如何切入 -->
	<tx:advice id="txAdvice" transaction-manager="transactionManager">
		<tx:attributes>
			<!-- *所有方法都是事物方法 -->
			<tx:method name="*"/>
			<!-- get所有方法都是查询方法 -->
			<tx:method name="get*" read-only="true"/>

		</tx:attributes>
	</tx:advice>

	<!-- Spring 配置的核心 1数据源 与2mybatis的整合 3事物控制的配置 -->
</beans>
